---
import '../assets/global.css';
import '../assets/scss/globals.scss';
import '../assets/default.css';
import SiteMeta from '../components/SiteMeta.astro';
import SiteNavigation from '../components/SiteNavigation.astro';
import SiteFooter from '../components/SiteFooter.astro';
import CookieConsent from '../components/CookieConsent.astro';
import DarkMode from '../components/DarkMode.astro';
import Preloader from '../components/Preloader.astro';
import { VisualEditing } from '@sanity/astro/visual-editing';
import { ViewTransitions } from 'astro:transitions';

import { getNavigation } from '../lib/sanity';

type Props = {
  children?: any;
  title: string;
  description?: string;
  image?: any;
  author?: any;
  seo?: any;
  url?: string;
};

const {
  title,
  description,
  image = '/social-preview-image.png',
  author = 'AstroBuildClubâ„¢',
  seo,
  url,
} = Astro.props;
const { menus, generalSettings } = await getNavigation();
const primaryMenu = menus.nodes[0];

// Visual Editing support
// Check environment variable (eerste prioriteit)
const envVisualEditingEnabled =
  import.meta.env.PUBLIC_SANITY_VISUAL_EDITING_ENABLED === 'true';

// Check URL parameter als fallback (voor productie)
// Gebruik Astro.request.url voor query parameters in SSR mode
const requestUrl = new URL(Astro.request.url);
const urlPreviewEnabled = requestUrl.searchParams.get('preview') === 'true';

// Visual editing enabled wanneer:
// - Environment variable is true, OF
// - URL parameter preview=true is aanwezig
const visualEditingEnabled = envVisualEditingEnabled || urlPreviewEnabled;

// Debug logging (uitgecomment - alleen nodig bij troubleshooting)
// if (import.meta.env.DEV && seo) {
//   console.log('ðŸŽ¯ Layout SEO:', { title: seo.title?.substring(0, 30), url });
// }
---

<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <script is:inline>
      // Carry current theme into the incoming document before swap
      document.addEventListener('astro:before-swap', (event) => {
        try {
          const theme =
            localStorage.getItem('theme') ||
            document.documentElement.getAttribute('data-theme') ||
            'light';
          event.newDocument.documentElement.setAttribute('data-theme', theme);
        } catch (e) {}
      });
    </script>
    <script is:inline>
      (function () {
        try {
          const doc = document.documentElement;
          const stored = localStorage.getItem('theme');
          const prefersDark = window.matchMedia(
            '(prefers-color-scheme: dark)',
          ).matches;
          const theme = stored || (prefersDark ? 'dark' : 'light');
          doc.setAttribute('data-theme', theme);
        } catch (e) {}
      })();
    </script>
    <script is:inline>
      (function () {
        try {
          if (sessionStorage.getItem('preloader-shown') === 'true') return;
          if (
            window.matchMedia &&
            window.matchMedia('(prefers-reduced-motion: reduce)').matches
          ) {
            return;
          }
          const navEntry =
            typeof performance !== 'undefined' &&
            performance.getEntriesByType &&
            performance.getEntriesByType('navigation')[0];
          const navType = navEntry?.type;
          const legacyNavType =
            typeof performance !== 'undefined' &&
            performance.navigation &&
            performance.navigation.type;
          if (navType && navType !== 'navigate') return;
          if (legacyNavType && legacyNavType !== 0) return;
          document.documentElement.classList.add('preloader-active');
          document.documentElement.classList.add('preloader-lock-scroll');
        } catch (e) {}
      })();
    </script>
    <style>
      :root {
        --vt-snappy-duration: 190ms;
        --vt-snappy-ease: cubic-bezier(0.22, 0.61, 0.36, 1);
      }

      ::view-transition-old(page-main),
      ::view-transition-new(page-main) {
        animation-duration: var(--vt-snappy-duration);
        animation-timing-function: var(--vt-snappy-ease);
      }

      ::view-transition-old(page-main) {
        animation-name: vt-snappy-out;
      }

      ::view-transition-new(page-main) {
        animation-name: vt-snappy-in;
      }

      @keyframes vt-snappy-out {
        from {
          opacity: 1;
        }
        to {
          opacity: 0;
        }
      }

      @keyframes vt-snappy-in {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        ::view-transition-old(page-main),
        ::view-transition-new(page-main) {
          animation: none !important;
        }
      }

      body[data-navigating] main {
        opacity: 0.4;
        transition: opacity 180ms var(--vt-snappy-ease);
        will-change: opacity;
      }

      :root.preloader-lock-scroll,
      :root.preloader-lock-scroll body {
        overflow: hidden;
        overscroll-behavior: none;
        touch-action: none;
      }
      :root.preloader-active body > :not(#preloader) {
        visibility: hidden;
      }
      :root.preloader-active #preloader {
        position: fixed;
        inset: 0;
        z-index: 9999;
        background: var(--white, #ffffff);
        opacity: 1 !important;
        pointer-events: auto !important;
      }
      :root[data-theme='dark'].preloader-active #preloader {
        background: var(--black, rgb(12, 12, 12));
      }
      :root.preloader-active #preloader.is-bar-only {
        background: transparent;
      }
      :root.preloader-active #preloader .preloader__percent {
        display: block !important;
      }
      :root.preloader-active #preloader .preloader__bar {
        position: fixed;
        top: 0;
        left: 0;
        height: 3px;
        width: 0%;
        background: var(--white, #ffffff);
        mix-blend-mode: exclusion;
        z-index: 10000;
      }
    </style>
    <link rel="icon" href="/favicon.svg" type="image/svg+xml" />

    <!-- Font imports -->
    <link rel="stylesheet" href="https://use.typekit.net/yjz0kgm.css" />

    <!-- CookieConsent CSS -->

    <!-- CookieConsent CSS -->
    <link rel="stylesheet" href="/css/iframemanager.css" />
    <link rel="stylesheet" href="/css/cookieconsent.css" />
    <link rel="stylesheet" href="/css/preloader.css" />

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/orestbida/cookieconsent@v3.0.1/dist/cookieconsent.css"
    />

    <SiteMeta
      title={seo?.title || title}
      description={seo?.description || description}
      url={seo?.canonicalUrl ||
        url ||
        (Astro.site ? Astro.site.toString() : 'https://accessible-astro.dev')}
      image={seo?.metaImage || seo?.openGraph?.image || image}
      author={author}
      seo={seo}
    />
    <ViewTransitions />
  </head>

  <body>
    <Preloader />
    <SiteNavigation menu={primaryMenu} generalSettings={generalSettings} />
    <main
      class="page-layout pb-[var(--space-3xl)]"
      style="view-transition-name: page-main;"
    >
      <slot />
    </main>
    <SiteFooter />
    <CookieConsent />
    <DarkMode />
    <VisualEditing enabled={visualEditingEnabled} />
    <!-- JavaScript bestanden -->
    <script src="/js/cookieconsent.umd.js" is:inline></script>
    <script src="/js/iframemanager.js" is:inline></script>
    <script is:inline>
      // Re-scan embeds after Astro view transitions
      const __rescanEmbeds = () => {
        try {
          window.iframemanager &&
            window.iframemanager.scan &&
            window.iframemanager.scan();
        } catch (e) {}
      };
      document.addEventListener('astro:page-load', __rescanEmbeds);
      document.addEventListener('astro:after-swap', __rescanEmbeds);
    </script>
    <script is:inline>
      // Keep muted autoplay videos playing when other videos start
      (function () {
        function keepMutedVideosPlaying() {
          // Find all muted autoplay videos
          const mutedAutoplayVideos = Array.from(
            document.querySelectorAll('video'),
          ).filter((video) => {
            return video.muted && video.autoplay && video.loop;
          });

          if (mutedAutoplayVideos.length === 0) return;

          // Listen for play events on all videos
          document.addEventListener(
            'play',
            function (e) {
              const playingVideo = e.target;

              // If the playing video is not muted, resume all muted autoplay videos
              if (
                playingVideo &&
                playingVideo.tagName === 'VIDEO' &&
                !playingVideo.muted
              ) {
                mutedAutoplayVideos.forEach((video) => {
                  if (video !== playingVideo && video.paused) {
                    video.play().catch(() => {
                      // Ignore play errors (e.g., user interaction required)
                    });
                  }
                });
              }
            },
            true,
          );

          // Also handle pause events - if a muted video gets paused, try to resume it
          mutedAutoplayVideos.forEach((video) => {
            video.addEventListener('pause', function () {
              // Only resume if it's still muted and should be autoplaying
              if (this.muted && this.autoplay && this.loop) {
                // Small delay to avoid conflicts
                setTimeout(() => {
                  if (this.paused && this.muted) {
                    this.play().catch(() => {
                      // Ignore play errors
                    });
                  }
                }, 100);
              }
            });
          });
        }

        // Run on page load
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', keepMutedVideosPlaying);
        } else {
          keepMutedVideosPlaying();
        }

        // Re-run after Astro view transitions
        document.addEventListener('astro:page-load', keepMutedVideosPlaying);
        document.addEventListener('astro:after-swap', keepMutedVideosPlaying);
      })();
    </script>
    <script is:inline>
      (function () {
        const processed = 'data-fade-on-view-ready';

        function isInInitialView(el) {
          const rect = el.getBoundingClientRect();
          const vh = window.innerHeight || document.documentElement.clientHeight;
          return rect.top < vh * 0.92 && rect.bottom > 0;
        }

        function initImageFadeInOnView() {
          if (
            window.matchMedia &&
            window.matchMedia('(prefers-reduced-motion: reduce)').matches
          ) {
            return;
          }

          const images = document.querySelectorAll(`main img:not([${processed}])`);
          if (!images.length) return;

          if (!('IntersectionObserver' in window)) {
            images.forEach((img) => {
              img.setAttribute(processed, 'true');
              img.classList.add('fade-on-view', 'is-visible');
            });
            return;
          }

          const observer = new IntersectionObserver(
            (entries, io) => {
              entries.forEach((entry) => {
                if (!entry.isIntersecting) return;
                entry.target.classList.add('is-visible');
                io.unobserve(entry.target);
              });
            },
            {
              threshold: 0.15,
              rootMargin: '0px 0px -8% 0px',
            },
          );

          images.forEach((img) => {
            img.setAttribute(processed, 'true');
            img.classList.add('fade-on-view');

            if (isInInitialView(img)) {
              img.classList.add('is-visible');
              return;
            }

            observer.observe(img);
          });
        }

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initImageFadeInOnView);
        } else {
          initImageFadeInOnView();
        }

        document.addEventListener('astro:page-load', initImageFadeInOnView);
        document.addEventListener('astro:after-swap', initImageFadeInOnView);
      })();
    </script>
    <script is:inline>
      (function () {
        const processed = 'data-stagger-ready';

        function isInInitialView(el) {
          const rect = el.getBoundingClientRect();
          const vh = window.innerHeight || document.documentElement.clientHeight;
          return rect.top < vh * 0.92 && rect.bottom > 0;
        }

        function getTargets(container) {
          const selector = container.getAttribute('data-stagger-selector');
          if (selector) {
            try {
              const selected = Array.from(container.querySelectorAll(selector));
              if (selected.length) return selected;
            } catch (e) {}
          }
          return Array.from(container.children);
        }

        function initStaggerOnView() {
          const containers = document.querySelectorAll(
            `[data-stagger-on-view]:not([${processed}])`,
          );
          if (!containers.length) return;

          const reducedMotion =
            window.matchMedia &&
            window.matchMedia('(prefers-reduced-motion: reduce)').matches;

          if (reducedMotion || !('IntersectionObserver' in window)) {
            containers.forEach((container) => {
              const targets = getTargets(container);
              targets.forEach((target, index) => {
                target.classList.add('stagger-on-view-item');
                target.style.setProperty('--stagger-index', String(index));
              });
              container.classList.add('is-visible');
              container.setAttribute(processed, 'true');
            });
            return;
          }

          const observer = new IntersectionObserver(
            (entries, io) => {
              entries.forEach((entry) => {
                if (!entry.isIntersecting) return;
                entry.target.classList.add('is-visible');
                io.unobserve(entry.target);
              });
            },
            {
              threshold: 0.12,
              rootMargin: '0px 0px -8% 0px',
            },
          );

          containers.forEach((container) => {
            const targets = getTargets(container);
            targets.forEach((target, index) => {
              target.classList.add('stagger-on-view-item');
              target.style.setProperty('--stagger-index', String(index));
            });

            container.setAttribute(processed, 'true');

            if (isInInitialView(container)) {
              container.classList.add('is-visible');
              return;
            }

            observer.observe(container);
          });
        }

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initStaggerOnView);
        } else {
          initStaggerOnView();
        }

        document.addEventListener('astro:page-load', initStaggerOnView);
        document.addEventListener('astro:after-swap', initStaggerOnView);
      })();
    </script>
    <script is:inline>
      (function () {
        const processed = 'data-reveal-ready';
        const containerProcessed = 'data-reveal-container-ready';

        function isInInitialView(el) {
          const rect = el.getBoundingClientRect();
          const vh = window.innerHeight || document.documentElement.clientHeight;
          return rect.top < vh * 0.92 && rect.bottom > 0;
        }

        function initRevealOnView() {
          const containers = document.querySelectorAll(
            `[data-reveal-children]:not([${containerProcessed}])`,
          );

          containers.forEach((container) => {
            const selector =
              container.getAttribute('data-reveal-children') || ':scope > *';
            const step = Number(container.getAttribute('data-reveal-step') || 0);
            let items = [];

            try {
              items = Array.from(container.querySelectorAll(selector));
            } catch (e) {
              items = Array.from(container.children);
            }

            items.forEach((item, index) => {
              item.classList.add('reveal-on-view');
              item.setAttribute('data-reveal-on-view', '');
              if (step > 0) {
                item.style.setProperty('--reveal-delay', `${index * step}ms`);
              }
            });

            container.setAttribute(containerProcessed, 'true');
          });

          const targets = document.querySelectorAll(
            `[data-reveal-on-view]:not([${processed}])`,
          );
          if (!targets.length) return;

          const reducedMotion =
            window.matchMedia &&
            window.matchMedia('(prefers-reduced-motion: reduce)').matches;

          if (reducedMotion || !('IntersectionObserver' in window)) {
            targets.forEach((target) => {
              target.classList.add('is-visible');
              target.setAttribute(processed, 'true');
            });
            return;
          }

          const observer = new IntersectionObserver(
            (entries, io) => {
              entries.forEach((entry) => {
                if (!entry.isIntersecting) return;
                entry.target.classList.add('is-visible');
                io.unobserve(entry.target);
              });
            },
            {
              threshold: 0.12,
              rootMargin: '0px 0px -8% 0px',
            },
          );

          targets.forEach((target) => {
            target.setAttribute(processed, 'true');
            if (isInInitialView(target)) {
              target.classList.add('is-visible');
              return;
            }
            observer.observe(target);
          });
        }

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initRevealOnView);
        } else {
          initRevealOnView();
        }

        document.addEventListener('astro:page-load', initRevealOnView);
        document.addEventListener('astro:after-swap', initRevealOnView);
      })();
    </script>
  </body>
</html>

<style>
  main {
    padding-bottom: 20vh;
    background-color: var(--white);
    position: relative;
    z-index: 1;
  }

  /* Dark mode support */
  :root[data-theme='dark'] main {
    background-color: var(----clr-black: rgba(12, 12, 12) ;);
  }
</style>
